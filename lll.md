### C++ 编译与内存相关

#### C++ 程序编译

- 为什么需要编译：

  常见的 C/C++ 语言，CPU 是无法理解的，这就需要将我们编写好的代码最终翻译为机器可执行的二进制指令，编译的过程本质上也即是翻译的过程，当然中间涉及的细节非常复杂

- 编译的处理过程：

  编译器读取源文件 cpp，并将其翻译为可执行文件「ELF」，ELF 文件可以经过操作系统进行加载执行。常见的编译过程分为四个过程：编译预处理、编译、汇编、链接

  - 编译预处理：在预编译过程中**主要处理源代码中的预处理指令**，比如引入头文件（#include），去除注释，处理所有的条件编译指令（#ifdef, # ifndef, # else, # elif, # endif），宏的替换（#define），添加行号，保留所有的编译器指令；
  - 编译：针对预处理后的文件进行词法分析、语法分析、语义分析、符号汇总、汇编代码生成，并针对程序的结构或者特定的 CPU 平台进行优化，其中涉及的过程较为复杂。**简单来说编译的过程即为将 .cpp 源文件翻译成 .s 的汇编代码；**
  - 汇编：**将汇编代码 .s 翻译成机器指令 .o 文件**，一个 .cpp 文件只会生成一个 .o 文件；
  - 链接：汇编程序生成的目标文件即为 .o 文件，单独的 .o 文件可能无法执行。因为一个程序可能由多个源文件组成，此时就存在多个 .o 文件。文件 A 中的函数引用了另一个文件 B 中定义的符号或者调用了某个库文件中的函数，这就需要链接处理。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成一个可被操作系统加载执行的ELF 程序文件

- 静态链接与动态链接:

  - **静态链接：**代码在生成可执行文件时，将该程序所需要的全部外部调用函数全部拷贝到最终的可执行程序文件中，在该程序被执行时，该程序运行时所需要的全部代码都会被装入到该进程的虚拟地址空间中。在 Linux 系统下，静态链接库一般以 .a 文件，我们可以将多个 .o 文件链接成一个静态链接库
  - **动态链接：**代码在生成可执行文件时，该程序所调用的部分程序被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息，**最终生成的 ELF 文件中并不包含这些调用程序二进制指令**。在程序执行时，当需要调用这部分程序时，**操作系统会从将这些动态链或者共享对象进行加载**，并将全部内容会被映射到该进行运行的虚拟地址的空间。在 Linux 系统下，动态链接库一般以 .so 文件，我们可以将多个 .o 文件链接成一个动态链接库
  - **二者的优缺点：**静态链接**浪费空间**，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难），优点就是执行的时候**运行速度快**，因为可执行程序具备了程序运行的所有内容；动态链接**节省内存、更新方便**，但是动态链接是在程序运行时，每次执行都需要链接，**相比静态链接会有一定的性能损失**。静态链接是由连接器完成的，动态链接最终是由操作系统来完成链接的功能，动态链接在不同的操作系统下可能由不同的实现原理，比如在 Linux 系统下，动态链接库通常以 .so 文件存在，在 windows 下同下，动态链接库一般以 .dll 文件存在

#### C++ 内存管理

- ELF 文件：可执行与可链接格式 (Executable and Linkable Format) 是一种用于可执行文件、目标代码、共享库和**核心转储 （core dump）** 的标准文件格式，每个 ELF 文件都由一个 ELF header 和紧跟其后的文件数据部分组成，可执行程序内部都是分段进行存储的，ELF 文件的构成如下:

  <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220910114916326.png" alt="image-20220910114916326" style="zoom: 33%;" />

  - .text section：代码段。通常存放已编译程序的机器代码，一般操作系统加载后，这部分是只读的。
  - .rodatasection：只读数据段。此段的数据不可修改，存放程序中会使用的常量。比如程序中的常量字符串"aasdasdaaasdasd"。
  - .datasection：数据段。主要用于存放已初始化的全局变量、常量。
  - .bsssection: bss 段。该段主要存储未初始化全局变量，仅是占位符，不占据任何实际磁盘空间。目标文件格式区分初始化和非初始化是为了空间效率。

  操作系统在加载 ELF 文件时会将按照标准依次读取每个段中的内容，并将其加载到内存中，同时为该进程分配栈空间，并将 pc 寄存器指向代码段的起始位置，然后启动进程

- 内存分区：C++ 程序在运行时也会按照不同的功能划分不同的段，C++ 程序使用的内存分区一般包括：栈、堆、全局/静态存储区、常量存储区、代码区。

  - 栈：目前绝大部分 CPU 体系都是基于栈来运行程序，栈中主要存放函数的局部变量、函数参数、返回地址等，栈空间一般由操作系统进行默认分配或者程序指定分配，栈空间在进程生存周期一直都存在，当进程退出时，**操作系统才会对栈空间进行回收**。
  - 堆：动态申请的内存空间，就是由 malloc 函数或者 new 函数分配的内存块，由程序控制它的分配和释放，可以在程序运行周期内随时进行申请和释放，如果进程结束后还没有释放，操作系统会自动回收。
  - 全局区/静态存储区：主要为 .bss 段和 .data 段，存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。
  - 常量存储区：.rodata 段，存放的是常量，不允许修改，程序运行结束自动释放。
  - 代码区：.text 段，存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。
  - 从操作系统的本身来讲，以上存储区在该程序内存中的虚拟地址分布是如下形式（虚拟地址从低地址到高地址，实际的物理地址可能是随机的）： .text→.data→.bss→heap→unused→stack→⋯

#### 堆与栈

- 栈：每次在调用函数时，会按照从右向左的顺序依次将函数调用参数压入到栈中，并在栈中压入返回地址与当前的栈帧，然后跳转到调用函数内部，pc 跳转函数内部执行该函数的指令；
  - rsp 寄存器存放的地址即为当前的栈顶rbp 寄存器存放的地址即为当前的栈帧，与 rbp 寄存器相邻的位置存放的数据即为函数的返回地址与调用函数的栈帧，通过以上信息即可获取函数的调用关系

  - **栈溢出**：一般情况操作系统为每个进程会固定栈空间的大小，在实际编写程序时，如果出现两个函数互相调用或者递归无退出条件时，此时栈空间的就会无限增长
  - 栈一般还分为内核栈与用户栈，在栈顶会有一个特殊的内存页 `guard`，当栈一旦越界访问该特殊的 `guard` 页时，则会出现栈溢出的错误
- 堆：当程序在运行时，需要动态申请额外的内存来存放相应的数据和变量，此时就需要用到堆。堆的内存空间一般由操作系统或者专门内存程序来管理的。在 C/C++ 一般用 malloc 或者 new 来从堆中申请内存，使用 free 或者 delete 来释放空间，空间释放后会有**操作系统**进行回收。

- 堆与栈的优缺点：

  - 申请方式：栈中存放的变量在编译时由编译器为其在栈上分配了空间，即程序编译后该变量在栈中使用的内存即确定，释放时也由于函数调用的返回，栈的空间会自动进行回收。堆中存放的变量由程序运行时决定的，会有操作系统或者内存管理模块来进行分配的。
  - 申请后系统响应：
    - 分配栈空间时如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出，绝大多数情况下，栈的空间较小，一般栈上分配的变量不会占用太大的空间，且当函数返回时，当前栈帧中的变量生存周期会结束；
    - 申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上，堆上可以分配较大的空间，如果不进行释放，则堆上存储的变量生存周期一直存在，直到当前进程退出
    - 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，且只能被当前的线程访问；堆在内存中的空间（向高地址扩展）是不连续的，中间允许有间隔，堆中的内存并不是线程安全的，同一进程的线程都都可访问。
  - 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。
  - 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。
- 实际的内存管理
  - 实际的内存管理更为复杂，一般分为两级内存管理。
  - 操作系统按照段页式来管理内存，当需要创建新的进程或者线程时，操作系统会为新创建的进程分配物理页，当运行的进程需要更多的内存时，操作系统也会为其分配新的物理页并将其映射到该进程的虚拟地址空间中。
  - 程序运行时，每个程序都含有一个内存管理的子程序，专门负责程序中的内存申请和释放，其中的技巧可能非常复杂，并且涉及许多内存分配的算法。

#### 变量定义与生存周期

`C/C++` 变量有两个非常重要的属性：作用域与生命周期，这两个属性代表从时间和空间两个不同的维度来描述一个变量

- 作用域：作用域即一个变量可以被引用的范围，常见的作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。
  - 全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。
  - 静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。
  - 局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回，局部变量对于函数外部的程序来说是不可见的。当然内部实际更复杂，实际是以 {} 为作用域的。
  - 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见, 只有定义该变量的函数内部可以使用访问和修改该变量。


- 生命周期：生命周期即该变量可以被引用的时间段（生存期表示变量存在的时间）。
  - 全局变量与局部全局变量: 全局变量在整个程序运行期间都会一直存在，都可以随时访问，当程序结束时，对应的变量则会自动销毁，内存会被系统回收。
  - 局部变量: 局部变量的生命周期仅限于函数被调用期间，当函数调用结束时，该变量会自动销毁。
  - 静态局部变量：实际上静态局部变量的作用域仅限于函数内部，它的作用域与局部变量相同，但实际上该变量在程序运行期间是一直存在的，生命周期贯穿于整个程序运行期间。局部静态变量只能被初始化一次。

- 从分配内存空间看：不同生命周期的变量，在程序内存中的分布位置是不一样的。程序的内存分为代码区（.text）、全局数据区（.data，.bss，.rodata）、堆区（heap）、栈区（stack），不同的内存区域，对应不同的生命周期
  - 静态变量一般存储在数据段，包括 data 段、bss 段、rodata 段，其中 data 存储已经已经初始化的静态变量和全局变量，bss 存储未初始化的静态变量与全局变量。静态变量包括全局变量，局部全局变量，静态局部变量。
  - 局部变量一般存储在栈区或者堆区。
- 静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段，bss 段，rodata 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。
- 静态变量和全局变量的区别：静态变量仅在变量的作用范围内可见，实际是依靠编译器来控制作用域。全局变量在整个程序范围内都可可见，只需声明该全局变量，即可使用。
- 全局变量定义在不要在头文件中定义：如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，编译时会因为重复定义而报错，因此不能再头文件中定义全局变量。一般情况下我们将变量的定义放在 .cpp 文件中，一般在 .h 文件使用extern 对变量进行声明。

#### 内存对齐

- 什么是内存对齐：计算机中内存空间是按照 byte 来划分划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是：在访问特定类型变量的时候通常在特定的内存地址访问，这就需要对这些数据在内存中存放的位置进行限制，各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。编译器将程序中的每个 数据单元 的地址安排在机器字的整数倍的地址指向的内存之中

- 为什么要内存对齐：主要是由于 CPU 的访问内存的特性决定，CPU 访问内存时并不是以字节为单位来读取内存，而是以机器字长为单位，由 CPU 的数据总线的宽度来决定的。实际 CPU 运行时，每一次控制内存读写信号发生时，CPU 一次可以读取和写入数据总线宽度的数据。比如 32 位的 CPU，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。这么设计的目的是为了减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。假设读取 8 个字节的数据，按照每次读取 4 个字节的速度，则 8 个字节需要 CPU 耗费 2 次读取操作。CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数。

  除了能够减少内存访问次数，增加内存读取的吞吐量以外，还有其他原因：

  - 比如某些特定的硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常，比如对于 CPU 中 SIMD 指令，则必须要求内存严格对齐；
  - 每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的。某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作，因此此时 CPU 需要可能需要读取多次内存，这样就破坏了变量的原子性；
  - 相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间，提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取；
  - 某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）；
  - 某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。

- 内存对齐的原则：

  - 实际的内存对齐处理都是由编译器来处理，编译器会自动在内存之间填充字节。结构体重变量对齐的基本规则如下：
    - 结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；
    - 结构体中的 static 成员变量不占用结构体的空间，由于静态成员变量在程序初始化时已经在静态存储区分配完成，所有该结构体实例中的静态成员都指向同一个内存区域；
    - 结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）；
    - 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）；

- 在某些特定场景下需要指定结构体内存进行对齐，比如在发送特定网络协议报文、硬件协议控制、消息传递、硬件寄存器访问时，这时就就需要避免内存对齐，因为双方均按照预先定义的消息格式来进行交互，从而避免不同的硬件平台造成的差异，同时能够将双方传递的数据进行空间压缩，避免不必要的空间浪费。可以用 `#progma pack(x)` 指定结构体以 x 为单位进行对齐

- 内存对齐使得程序便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；另一方面提高内存的访问效率，因为 CPU 在读取内存时，是以块为单位进行读取


#### 大端与小端

- 字节序又称端序或尾序（`Endianness`），在计算机科学领域中，指电脑内存中或在数字通信链路中，组成多字节的字的字节的排列顺序。

- 字节的排列方式常见的方式有两种：将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称小端序（Little-Endian）；反之则称大端序（Big-Endian）。为什么需要字节序这个规定，主要是因为在网络应用中字节序是一个必须被考虑的因素，对于不同 CPU 可能采用不同标准的字节序，所以均按照网络标准转化成相应的字节序。

  - Little-Endian：将低序字节存储在起始地址（低位编址），在变量指针转换的时候地址保持不变，比如 int64* 转到 int32*，对于机器计算来说更友好和自然
  - Big-Endian：将高序字节存储在起始地址（高位编址），内存顺序和数字的书写顺序是一致的，对于人的直观思维比较容易理解，网络字节序统一规定采用 Big-Endian。

- 检测字节序:
  一般情况下我们直接调用宏定义 __BYTE_ORDER 即可，可以通过引用 <bits/endian.h> 即可。或者也可以编写程序来判断当前的字节序

  ```C
  bool byteorder_check() {
      int a = 1;
      return (*(char *)&a); /* 1 为小端机，0 为大端机 */
  }
  ```

- 字节序转换:在程序中字节序转换时，将高位与低位依次进行交换即可完成

  常用的网络字节序转换函数:

  ```c++
  ntohl(uint32 x)       // uint32 类型 网络序转主机序
  htonl(uint32 x)       // uint32 类型 主机序转网络序
  ntohs(uint16 x)       // uint16 类型 网络序转主机序
  htons(uint16 x)       // uint16 类型 主机序转网络序
  ```


#### 内存泄漏

- 内存泄漏：程序在堆中申请的动态内存，在程序使用完成时没有得到及时的释放。当这些变量的生命周期已结束时，该变量在堆中所占用的内存未能得到释放，从而就导致了堆中可使用的内存越来越少，最终可能产生系统运行较慢或者系统因内存不足而崩溃的问题。
- 内存泄漏并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。
- 内存泄漏主要指堆上分配的变量，因为栈中分配的变量，随着函数退出时会自动回收。而堆是动态分配的，一旦用户申请了内存分配而没及时释放，那么该部分内存在整个程序运行周期内都是被占用的，其他程序无法再使用这部分内存。
- 对于实际的程序来说，在调用过程中使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。在实际应用中，可能在使用系统资源或者在堆中创建对象时，没有及时将这些资源或者对象进行释放时，也会造成内存泄漏，这些资源或者对象的创建实际也占用了堆中的内存，在使用完成时应及时将其进行释放
- 内存泄漏导致的问题：由于内存未得到及时释放，从而可能导致可使用的动态内存空间会越来越少，一旦内存空间全部使用完，则程序可能会导致因为内存不够中止运行。由于内存泄漏导致的问题比较严重，现在许多语言都带有 GC 程序会自动对不使用的内存进行回收，从而避免内存泄漏。

#### 内存泄漏检测与预防

- 对于 C/C++ 没有 GC 程序的语言来说因为内存造成的问题较多，当然一般情况下如果存在严重的内存泄漏，通过查看内存使用统计即可检测到内存泄漏，但是细小的内存泄漏很难通过统计观察到，目前一般都是利用各种内存检测工具来检测内存泄漏，当然关键还是在于统计和分析申请和释放的相关日志。内存检测工具有很多比如valgrind等

- 如何防止内存泄漏:

  - 内部封装：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存；但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况:

    ```C++
    void fun1()
    {
        A ex(100);
        A ex1 = ex; 
        char *p = ex.GetPointer();
        strcpy(p, "Test");
        cout << p << endl;
    }
    ```

    对于 fun1 这个函数中定义的两个类的对象而言，在离开该函数的作用域时，会两次调用析构函数来释放空间。但是这两个对象指向的是同一块内存空间，所以导致同一块内存空间被释放两次，可以通过增加计数机制来避免这种情况

  - 使用智能指针：智能指针是 C++ 中已经对内存泄漏封装好了一个工具，智能指针对象会自动释放所申请的内存

  - 良好的编码习惯：良好的编码习惯可以有效的避免内存泄漏的问题，内存申请和释放要一一对应：

    - 在 C++ 中需要将基类的析构函数定义为虚函数；
    - 遵循 RAII（Resource acquisition is initialization）原则：在对象构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源；
    - 尽量使用智能指针；
    - 有效引入内存检测工具；

#### 智能指针简介与使用

- 智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++ 11 中提供了智能指针的定义，所有关于智能指针的定义可以参考 <memory> 头文件。传统的指针在申请完成后，必须要调用 free 或者 delete 来释放指针，否则容易产生内存泄漏的问题；
- smart pointer 遵循 RAII 原则，当 smart pointer 对象创建时，即为该指针分配了相应的内存，当对象销毁时，析构函数会自动释放内存。需要注意的是，智能指针不能像普通指针那样支持加减运算。
- 同时 `smart pointer` 重载了 `*` 和 `->` 等操作，使用该对象就像 `C` 语言中的普通指针一样，但是区别于普通指针的它会自动释放所申请的内存资源
- 按照常用的使用用途，智能指针有三类:
  - unique_ptr：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值
  - shared_ptr：与 unique_ptr 不同的是，shared_ptr 中资源可以被多个指针共享，但是多个指针指向同一个资源不能被释放多次，因此使用计数机制表明资源被几个指针共享；通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，同时将计数减一，当计数减为 0 时会自动释放内存空间，从而避免了内存泄漏。
    - 特别需要注意的是 shared_ptr 并不是线程安全的，但 shared_ptr 的计数是原子操作实现的，利用 atmoic CAS 指令实现。可以看到 share_ptr 的内存模型，当引用计数和 weak count 同时为 0 时，share_ptr 对象才会被最终释放掉
    - shared_ptr 通过引用计数的方式来管理对象，当进行拷贝或赋值操作时，每个 shared_ptr 都会记录当前对象的引用计数，当引用计数为0时，内存将被自动释放。当对 shared_ptr 赋予新值或者被对象被销毁时，引用计数会递减。但特殊情况出现循环引用时，shared_ptr 无法正常释放资源。循环引用，即 A 指向 B，B 指向 A，在表示双向关系时，是很可能出现这种情况的

  - weak_ptr：指向 share_ptr 指向的对象，能够解决由 shared_ptr 带来的循环引用问题。与 shared_ptr 配合使用，将 weak_ptr 转换为 share_ptr 时，虽然它能访问 share_ptr 所指向的资源但却不享有资源的所有权，不影响该资源的引用计数。有可能资源已被释放，但 weak_ptr 仍然存在，share_ptr 必须等待所有引用的 weak_ptr 全部被释放才会进行释放。因此每次访问资源时都需要判断资源是否有效


#### 智能指针的创建

- make_unique 在 C++ 14 以后才被加入到标准的 C++ 中，make_shared 则是 C++ 11 中加入的。优先选用 std::make_unique 和 std::make_shared,而非直接 new
- make_unique：减少代码量，能够加快编译速度，定义两遍类型时，编译器需要进行类型推导会降低编译速度，某些意外意外情况下可能会导致内存泄漏。但是 make_unique 不允许自定析构器，不接受 std::initializer_list 对象
- `make_shared`：这个主要是可以减少对堆中申请内存的次数，只需要申请一次即可
  - 使用 new 时，我们将 new 出的资源指针赋给 share_ptr 的 ptr, 然后 share_ptr 本身还需要再次在堆上申请一块单独的内存作为它的管理区，存放引用计数、用户自定的函数等，因此创建 shared_ptr 时需要在堆上申请两次。
    `C++ [] std::shared_ptr<Widget>(new Widget);`
  - 当我们使用 make_share 时，我们只需要申请一块大的内存，一半用来存储资源，另一半作为管理区, 存放引用计数、用户自定的函数等，此时需要在堆上申请一次即可。
    `C++ auto upw1(std::make_unique<Widget>());`
  - make_share 虽然效率高，但是同样不能自定义析构器，同时 share_ptr 的对象资源可能会延迟释放，因为此时对象资源与管理区域在同一块内存中，必须要同时释放。


#### include " " 和 <> 的区别

- include 关键字主要用来标识 C/C++ 程序源代码编译时需要引用的头文件，编译器会自动去查找这些头文件中的变量、函数声明、结构体定义等相关信息，常见的有 include <filename> 和 #include "filename"，二者之间的区别:
  - 查找文件的位置：include<filename> 通常在编译器或者 IDE 中预先指定的搜索目录中进行搜索，通常会搜索 /usr/include 目录，此方法通常用于包括标准库头文件；#include "filename" 在当前源文件所在目录中进行查找，如果没有；再到当前已经添加的系统目录（编译时以 -I 指定的目录）中查找，最后会在 /usr/include 目录下查找 
  - 日常编写程序时，对于标准库中的头文件常用 include<filename>，对于自己定义的头文件常用 #include "filename"。
- __has_include：C++ 17 支持该特性，用来检查是否已经包含某个文件:

